#!/usr/bin/env bash
set -euo pipefail

# Configuration
DEFAULT_FLAGS=()
# readonly IMAGE_NAME="claudebox"  # Now computed per project
readonly DOCKER_USER="claude"
readonly USER_ID=$(id -u)
readonly GROUP_ID=$(id -g)
readonly PROJECT_DIR="$(pwd)"

# ────────────────────────────────────────────────────────────────────────────────
#  Cross-platform host detection (Linux vs. macOS) and FS case-sensitivity check
# ────────────────────────────────────────────────────────────────────────────────
OS_TYPE="$(uname -s)"
case "$OS_TYPE" in
  Darwin*) HOST_OS="macOS" ;;
  Linux*)  HOST_OS="linux" ;;
  *) echo "Unsupported operating system: $OS_TYPE" >&2; exit 1 ;;
esac

# Detect case‑insensitive default macOS filesystems (HFS+/APFS)
# Exit code 0  → case‑sensitive, 1 → case‑insensitive
is_case_sensitive_fs() {
  local t1 t2
  t1="$(mktemp "/tmp/.fs_case_test.XXXXXXXX")"
  # More portable uppercase conversion
  t2="$(echo "$t1" | tr '[:lower:]' '[:upper:]')"
  touch "$t1"
  [[ -e "$t2" && "$t1" != "$t2" ]] && { rm -f "$t1"; return 1; }
  rm -f "$t1"
  return 0
}

# Normalise docker‑build contexts on case‑insensitive hosts to avoid collisions
if [[ "$HOST_OS" == "macOS" ]] && ! is_case_sensitive_fs; then
  export COMPOSE_DOCKER_CLI_BUILD=1   # new BuildKit path‑normaliser
  export DOCKER_BUILDKIT=1
fi


# Cross-platform script path resolution
get_script_path() {
    local source="${BASH_SOURCE[0]:-$0}"
    while [[ -L "$source" ]]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
    done
    echo "$(cd -P "$(dirname "$source")" && pwd)/$(basename "$source")"
}
readonly SCRIPT_PATH="$(get_script_path)"

readonly LINK_TARGET="$HOME/.local/bin/claudebox"
readonly NODE_VERSION="--lts"
readonly DELTA_VERSION="0.17.0"

# Color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m'

# Utility functions
cecho() { echo -e "${2:-$NC}$1${NC}"; }
error() { cecho "$1" "$RED" >&2; exit "${2:-1}"; }
warn() { cecho "$1" "$YELLOW"; }
info() { cecho "$1" "$BLUE"; }
success() { cecho "$1" "$GREEN"; }

# Parse early flags
VERBOSE=false

for arg in "$@"; do   # SC2068 is fine – we want word–splitting on purpose here
    case "$arg" in
        --verbose) VERBOSE=true ; shift ;;
    esac
done

# Load saved default flags if they exist
if [[ -f "$HOME/.claudebox/default-flags" ]]; then
    while IFS= read -r flag; do
        [[ -n "$flag" ]] && DEFAULT_FLAGS+=("$flag")
    done < "$HOME/.claudebox/default-flags"
fi

# Logo
logo() {
    local cb='
 ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
██║     ██║     ███████║██║   ██║██║  ██║█████╗
██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
 ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝

██████╗  ██████╗ ██╗  ██╗ ------ ┌──────────────┐
██╔══██╗██╔═══██╗╚██╗██╔╝ ------ │ The Ultimate │
██████╔╝██║   ██║ ╚███╔╝  ------ │ Claude Code  │
██╔══██╗██║   ██║ ██╔██╗  ------ │  Docker Dev  │
██████╔╝╚██████╔╝██╔╝ ██╗ ------ │ Environment  │
╚═════╝  ╚═════╝ ╚═╝  ╚═╝ ------ └──────────────┘
'
    while IFS= read -r l; do
        o="" c=""
        for ((i=0;i<${#l};i++)); do
            ch="${l:$i:1}"
            [[ "$ch" == " " ]] && { o+="$ch"; continue; }
            cc=$(printf '%d' "'$ch" 2>/dev/null||echo 0)
            if [[ $cc -ge 32 && $cc -le 126 ]]; then n='\033[33m'
            elif [[ $cc -ge 9552 && $cc -le 9580 ]]; then n='\033[34m'
            elif [[ $cc -eq 9608 ]]; then n='\033[31m'
            else n='\033[37m'; fi
            [[ "$n" != "$c" ]] && { o+="$n"; c="$n"; }
            o+="$ch"
        done
        echo -e "${o}\033[0m"
    done <<< "$cb"
}

update_symlink() {
    # Ensure the directory exists
    mkdir -p "$(dirname "$LINK_TARGET")"

    # Check if symlink exists and points to the correct location
    if [[ -L "$LINK_TARGET" ]]; then
        local current_target
        current_target=$(readlink "$LINK_TARGET" 2>/dev/null || echo "")
        if [[ "$current_target" == "$SCRIPT_PATH" ]]; then
            [[ "$VERBOSE" == "true" ]] && info "Symlink already correct: $LINK_TARGET → $SCRIPT_PATH"
            return 0
        else
            # Remove incorrect symlink
            rm -f "$LINK_TARGET"
            [[ "$VERBOSE" == "true" ]] && info "Removing outdated symlink"
        fi
    elif [[ -e "$LINK_TARGET" ]]; then
        # Something else exists at this path
        error "Cannot create symlink: $LINK_TARGET already exists and is not a symlink"
    fi

    # Create new symlink
    if ln -s "$SCRIPT_PATH" "$LINK_TARGET"; then
        success "Symlink updated: $LINK_TARGET → $SCRIPT_PATH"
    else
        warn "Could not create symlink at $LINK_TARGET"
        warn "Try running with sudo or ensure $(dirname "$LINK_TARGET") is writable"
        warn "Error: $?"
    fi
}

# Docker checks
check_docker() {
    command -v docker &>/dev/null || return 1
    docker info &>/dev/null || return 2
    docker ps &>/dev/null || return 3
    return 0
}

install_docker() {
    warn "Docker is not installed."
    cecho "Would you like to install Docker now? (y/n)" "$CYAN"
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || error "Docker is required. Visit: https://docs.docker.com/engine/install/"

    info "Installing Docker..."

    [[ -f /etc/os-release ]] && . /etc/os-release || error "Cannot detect OS"

    case "${ID:-}" in
        ubuntu|debian)
            warn "Installing Docker requires sudo privileges..."
            sudo apt-get update
            sudo apt-get install -y ca-certificates curl gnupg lsb-release
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL "https://download.docker.com/linux/$ID/gpg" | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$ID $(lsb_release -cs) stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            ;;
        fedora|rhel|centos)
            warn "Installing Docker requires sudo privileges..."
            sudo dnf -y install dnf-plugins-core
            sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
            sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            sudo systemctl start docker
            sudo systemctl enable docker
            ;;
        arch|manjaro)
            warn "Installing Docker requires sudo privileges..."
            sudo pacman -S --noconfirm docker
            sudo systemctl start docker
            sudo systemctl enable docker
            ;;
        *)
            error "Unsupported OS: ${ID:-unknown}. Visit: https://docs.docker.com/engine/install/"
            ;;
    esac

    success "Docker installed successfully!"
    configure_docker_nonroot
}

configure_docker_nonroot() {
    warn "Configuring Docker for non-root usage..."
    warn "This requires sudo to add you to the docker group..."

    getent group docker >/dev/null || sudo groupadd docker
    sudo usermod -aG docker "$USER"

    success "Docker configured for non-root usage!"
    warn "You need to log out and back in for group changes to take effect."
    warn "Or run: ${CYAN}newgrp docker"
    warn "Then run 'claudebox' again."
    info "Trying to activate docker group in current shell..."
    exec newgrp docker
}

# Spinner
show_spinner() {
    local pid=$1 msg=$2 spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏' i=0
    echo -n "$msg "
    while kill -0 "$pid" 2>/dev/null; do
        printf "\b%s" "${spin:i++%${#spin}:1}"
        sleep 0.1
    done
    echo -e "\b${GREEN}✓${NC}"
}

# Bash 3.2 compatible profile functions (no associative arrays)
get_profile_packages() {
    case "$1" in
        core) echo "gcc g++ make git pkg-config libssl-dev libffi-dev zlib1g-dev tmux" ;;
        build-tools) echo "cmake ninja-build autoconf automake libtool" ;;
        shell) echo "rsync openssh-client man-db gnupg2 aggregate file" ;;
        networking) echo "iptables ipset iproute2 dnsutils" ;;
        c) echo "gdb valgrind clang clang-format clang-tidy cppcheck doxygen libboost-all-dev libcmocka-dev libcmocka0 lcov libncurses5-dev libncursesw5-dev" ;;
        openwrt) echo "rsync libncurses5-dev zlib1g-dev gawk gettext xsltproc libelf-dev ccache subversion swig time qemu-system-arm qemu-system-aarch64 qemu-system-mips qemu-system-x86 qemu-utils" ;;
        rust) echo "" ;;  # Rust installed via rustup
        python) echo "" ;;  # Managed via uv
        go) echo "" ;;  # Installed from tarball
        javascript) echo "" ;;  # Installed via nvm
        java) echo "openjdk-17-jdk maven gradle ant" ;;
        ruby) echo "ruby-full ruby-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev software-properties-common" ;;
        php) echo "php php-cli php-fpm php-mysql php-pgsql php-sqlite3 php-curl php-gd php-mbstring php-xml php-zip composer" ;;
        database) echo "postgresql-client mysql-client sqlite3 redis-tools mongodb-clients" ;;
        devops) echo "docker.io docker-compose kubectl helm terraform ansible awscli" ;;
        web) echo "nginx apache2-utils httpie" ;;
        embedded) echo "gcc-arm-none-eabi gdb-multiarch openocd picocom minicom screen platformio" ;;
        datascience) echo "r-base" ;;
        security) echo "nmap tcpdump wireshark-common netcat-openbsd john hashcat hydra" ;;
        ml) echo "" ;;  # Just cmake needed, comes from build-tools now
        *) echo "" ;;
    esac
}

get_profile_description() {
    case "$1" in
        core) echo "Core Development Utilities (compilers, VCS, shell tools)" ;;
        build-tools) echo "Build Tools (CMake, autotools, Ninja)" ;;
        shell) echo "Optional Shell Tools (fzf, SSH, man, rsync, file)" ;;
        networking) echo "Network Tools (IP stack, DNS, route tools)" ;;
        c) echo "C/C++ Development (debuggers, analyzers, Boost, ncurses, cmocka)" ;;
        openwrt) echo "OpenWRT Development (cross toolchain, QEMU, distro tools)" ;;
        rust) echo "Rust Development (installed via rustup)" ;;
        python) echo "Python Development (managed via uv)" ;;
        go) echo "Go Development (installed from upstream archive)" ;;
        javascript) echo "JavaScript/TypeScript (Node installed via nvm)" ;;
        java) echo "Java Development (OpenJDK 17, Maven, Gradle, Ant)" ;;
        ruby) echo "Ruby Development (gems, native deps, XML/YAML)" ;;
        php) echo "PHP Development (PHP + extensions + Composer)" ;;
        database) echo "Database Tools (clients for major databases)" ;;
        devops) echo "DevOps Tools (Docker, Kubernetes, Terraform, etc.)" ;;
        web) echo "Web Dev Tools (nginx, HTTP test clients)" ;;
        embedded) echo "Embedded Dev (ARM toolchain, serial debuggers)" ;;
        datascience) echo "Data Science (Python, Jupyter, R)" ;;
        security) echo "Security Tools (scanners, crackers, packet tools)" ;;
        ml) echo "Machine Learning (build layer only; Python via uv)" ;;
        *) echo "" ;;
    esac
}

get_all_profile_names() {
    echo "core build-tools shell networking c openwrt rust python go javascript java ruby php database devops web embedded datascience security ml"
}

profile_exists() {
    local profile="$1"
    for p in $(get_all_profile_names); do
        [[ "$p" == "$profile" ]] && return 0
    done
    return 1
}

expand_profile() {
    case "$1" in
        c) echo "core build-tools c" ;;
        openwrt) echo "core build-tools openwrt" ;;
        ml) echo "core build-tools ml" ;;
        rust|go|python|php|ruby|java|database|devops|web|embedded|datascience|security|javascript)
            echo "core $1"
            ;;
        shell|networking|build-tools|core)
            echo "$1"
            ;;
        *)
            echo "$1"
            ;;
    esac
}

docker_exec_root() {
    docker exec -u root "$@"
}

docker_exec_user() {
    docker exec -u "$DOCKER_USER" "$@"
}

# Standardized container run function - ensures consistent mounts and environment
run_claudebox_container() {
    local container_name="$1"
    local run_mode="$2"  # "interactive", "detached", "pipe", or "attached"
    shift 2
    local container_args=("$@")
    
    # Handle "attached" mode - start detached, wait, then attach
    if [[ "$run_mode" == "attached" ]]; then
        # Start detached
        run_claudebox_container "$container_name" "detached" "${container_args[@]}" >/dev/null
        
        # Show progress while container initializes
        fillbar
        
        # Wait for container to be ready
        while ! docker exec "$container_name" true 2>/dev/null; do
            sleep 0.1
        done
        
        fillbar stop
        
        # Attach to ready container
        docker attach "$container_name"
        
        return
    fi
    
    local docker_args=()
    
    # Set run mode
    case "$run_mode" in
        "interactive")
            # Only use -it if we have a TTY
            if [ -t 0 ] && [ -t 1 ]; then
                docker_args+=("-it")
            fi
            # Only add --rm if no container name (for persistence)
            if [[ -z "$container_name" ]]; then
                docker_args+=("--rm")
            else
                docker_args+=("--name" "$container_name")
            fi
            docker_args+=("--init")
            ;;
        "detached")
            docker_args+=("-d")
            if [[ -n "$container_name" ]]; then
                docker_args+=("--name" "$container_name")
            fi
            ;;
        "pipe")
            docker_args+=("--rm" "--init")
            ;;
    esac
    
    # Standard configuration for ALL containers
    docker_args+=(
        -w /workspace
        -v "$PROJECT_DIR":/workspace
        -v "$PROJECT_CLAUDEBOX_DIR/.claude":/home/$DOCKER_USER/.claude
        -v "$PROJECT_CLAUDEBOX_DIR/.claude.json":/home/$DOCKER_USER/.claude.json
        -v "$PROJECT_CLAUDEBOX_DIR/.config":/home/$DOCKER_USER/.config
        -v "$PROJECT_CLAUDEBOX_DIR/.cache":/home/$DOCKER_USER/.cache
        -v "$HOME/.ssh":"/home/$DOCKER_USER/.ssh:ro"
        -e "NODE_ENV=${NODE_ENV:-production}"
        -e "ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}"
        -e "CLAUDEBOX_PROJECT_NAME=$project_folder_name"
        -e "TERM=${TERM:-xterm-256color}"
        --cap-add NET_ADMIN
        --cap-add NET_RAW
        "$IMAGE_NAME"
    )
    
    # Add any additional arguments
    if [[ ${#container_args[@]} -gt 0 ]]; then
        docker_args+=("${container_args[@]}")
    fi
    
    docker run "${docker_args[@]}"
}

check_container_exists() {
    local container_name="$1"
    
    # Check if container exists (running or stopped)
    if docker ps -a --filter "name=^${container_name}$" --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
        # Check if it's running
        if docker ps --filter "name=^${container_name}$" --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
            echo "running"
        else
            echo "stopped"
        fi
    else
        echo "none"
    fi
}

FILLBAR_PID=""

fillbar() {
    case "${1:-}" in
        stop)
            if [ ! -z "$FILLBAR_PID" ]; then
                kill $FILLBAR_PID 2>/dev/null
            fi
            printf "\r\033[K"
            tput cnorm
            FILLBAR_PID=""
            ;;
        *)
            (
                p=0
                tput civis
                while true; do
                    printf "\r"
                    full=$((p / 8))
                    part=$((p % 8))
                    i=0
                    while [ $i -lt $full ]; do
                        printf "█"
                        i=$((i + 1))
                    done
                    if [ $part -gt 0 ]; then
                        pb=$(printf %x $((0x258F - part + 1)))
                        printf "\\u$pb"
                    fi
                    p=$((p + 1))
                    sleep 0.01
                done
            ) &
            FILLBAR_PID=$!
            ;;
    esac
}

show_help() {
    if docker image inspect "$IMAGE_NAME" &>/dev/null; then
        run_claudebox_container "" "pipe" --help | sed '1s/claude/claudebox/g'
        echo
        cecho "Added Options:" "$WHITE"
        echo -e "${CYAN}  --verbose                       ${WHITE}Show detailed output"
        echo -e "${CYAN}  --enable-sudo                   ${WHITE}Enable sudo without password"
        echo -e "${CYAN}  --disable-firewall              ${WHITE}Disable network restrictions"
        echo
        cecho "Added Commands:" "$WHITE"
        echo -e "  profiles                        List all available profiles"
        echo -e "  projects                        List all projects with paths"
        echo -e "  profile                         Profile management menu"
        echo -e "  install <packages>              Install apt packages"
        echo -e "  save [flags...]                 Save default flags (no args = clear saved flags)"
        echo -e "  shell                           Open transient shell (changes NOT saved)"
        echo -e "  shell admin                     Open admin shell (sudo, no firewall, changes saved)"
        echo -e "  allowlist                       Show/edit firewall allowlist"
        echo -e "  info                            Show comprehensive project info"
        echo -e "  clean                           Menu of cleanup tasks"
        echo -e "  unlink                          Remove claudebox symlink"
        echo -e "  rebuild                         Rebuild the Docker image from scratch${NC}"
    else
        cecho "ClaudeBox - Claude Code Docker Environment" "$CYAN"
        echo
        warn "First run setup required!"
        echo "Run script without arguments first to build the Docker image."
    fi
}

get_project_folder_name() {
    local clean_name=$(echo "$1" | sed 's|^/||; s|[^a-zA-Z0-9]|_|g; s|_+|_|g; s|^_||; s|_$||' | tr '[:upper:]' '[:lower:]')
    local hash=$(echo -n "$1" | sha256sum | cut -c1-6)
    echo "${clean_name}_${hash}"
}

get_profile_file_path() {
    local project_id=$(get_project_folder_name "$PROJECT_DIR")
    local project_dir="$HOME/.claudebox/projects/$project_id"
    mkdir -p "$project_dir"
    echo "$project_dir/config.ini"
}

read_config_value() {
    local config_file="$1"
    local section="$2"
    local key="$3"

    [[ -f "$config_file" ]] || return 1

    awk -F ' *= *' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$config_file"
}

get_project_by_path() {
    local search_path="$1"
    local abs_path=$(realpath "$search_path" 2>/dev/null || echo "$search_path")
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        local config_file="$project_dir/config.ini"
        [[ -f "$config_file" ]] || continue
        local stored_path=$(read_config_value "$config_file" "project" "path")
        if [[ "$stored_path" == "$abs_path" ]]; then
            basename "$project_dir"
            return 0
        fi
    done
    return 1
}

list_all_projects() {
    local projects_found=0
    # shellcheck disable=SC2231 # We want pathname expansion even when no dirs
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        projects_found=1
        local project_id=$(basename "$project_dir")
        local original_path="(unknown)"
        local image_status="❌"
        local image_size="-"
        local config_file="$project_dir/config.ini"
        if [[ -f "$config_file" ]]; then
            local path_value=$(read_config_value "$config_file" "project" "path")
            [[ -n "$path_value" ]] && original_path="$path_value"
        fi
        local image_name="claudebox-${project_id}"
        if docker image inspect "$image_name" &>/dev/null; then
            image_status="✅"
            image_size=$(docker images --filter "reference=$image_name" --format "{{.Size}}")
        fi
        printf "%10s  %s  %s\n" "$image_size" "$image_status" "$original_path"
    done
    [[ $projects_found -eq 0 ]] && return 1
    return 0
}

resolve_project_path() {
    local input_path="${1:-$PWD}"

    if [[ "$input_path" =~ _[a-f0-9]{6}$ ]] && [[ -d "$HOME/.claudebox/$input_path" ]]; then
        echo "$input_path"
        return 0
    fi

    local project_id=$(get_project_by_path "$input_path")
    if [[ -n "$project_id" ]]; then
        echo "$project_id"
        return 0
    fi

    return 1
}

read_profile_section() {
    local profile_file="$1"
    local section="$2"
    local result=()

    if [[ -f "$profile_file" ]] && grep -q "^\[$section\]" "$profile_file"; then
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^\[.*\]$ ]] && break
            result+=("$line")
        done < <(sed -n "/^\[$section\]/,/^\[/p" "$profile_file" | tail -n +2 | grep -v '^\[')
    fi

    printf '%s\n' "${result[@]}"
}

update_profile_section() {
    local profile_file="$1"
    local section="$2"
    shift 2
    local new_items=("$@")

    local existing_items=()
    readarray -t existing_items < <(read_profile_section "$profile_file" "$section")

    local all_items=()
    for item in "${existing_items[@]}"; do
        [[ -n "$item" ]] && all_items+=("$item")
    done

    for item in "${new_items[@]}"; do
        local found=false
        for existing in "${all_items[@]}"; do
            [[ "$existing" == "$item" ]] && found=true && break
        done
        [[ "$found" == "false" ]] && all_items+=("$item")
    done

    {
        if [[ -f "$profile_file" ]]; then
            awk -v sect="$section" '
                BEGIN { in_section=0; skip_section=0 }
                /^\[/ {
                    if ($0 == "[" sect "]") { skip_section=1; in_section=1 }
                    else { skip_section=0; in_section=0 }
                }
                !skip_section { print }
                /^\[/ && !skip_section && in_section { in_section=0 }
            ' "$profile_file"
        fi

        echo "[$section]"
        for item in "${all_items[@]}"; do
            echo "$item"
        done
        echo ""
    } > "${profile_file}.tmp" && mv "${profile_file}.tmp" "$profile_file"
}

setup_project_folder() {
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.claude"
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.config"
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.cache"
    if [[ ! -f "$PROJECT_CLAUDEBOX_DIR/.claude.json" ]]; then
        echo '{}' > "$PROJECT_CLAUDEBOX_DIR/.claude.json"
    fi

    local config_file="$PROJECT_CLAUDEBOX_DIR/config.ini"
    if [[ ! -f "$config_file" ]]; then
        cat > "$config_file" <<EOF
[project]
path = $PROJECT_DIR

[profiles]

[packages]
EOF
    fi
}


# Ensure shared commands folder exists and is up to date
setup_shared_commands() {
    local shared_commands="$HOME/.claudebox/commands"
    local script_dir="$(dirname "$SCRIPT_PATH")"
    local commands_source="$script_dir/commands"
    
    # Create shared commands directory if it doesn't exist
    mkdir -p "$shared_commands"
    
    # Copy/update commands from script directory if it exists
    if [[ -d "$commands_source" ]]; then
        # Copy new or updated files (preserve existing user files)
        cp -n "$commands_source/"* "$shared_commands/" 2>/dev/null || true
        
        # For existing files, only update if source is newer
        for file in "$commands_source"/*; do
            if [[ -f "$file" ]]; then
                local basename=$(basename "$file")
                local dest_file="$shared_commands/$basename"
                if [[ -f "$dest_file" ]] && [[ "$file" -nt "$dest_file" ]]; then
                    cp "$file" "$dest_file"
                    if [[ "$VERBOSE" == "true" ]]; then
                        info "Updated command: $basename"
                    fi
                fi
            fi
        done
        
        if [[ "$VERBOSE" == "true" ]]; then
            info "Synchronized commands to shared folder: $shared_commands"
        fi
    fi
}

setup_claude_agent_command() {
    # Create commands symlink in project's .claude folder (mounts to ~/.claude in container)
    local shared_commands="$HOME/.claudebox/commands"
    local commands_dest="$PROJECT_CLAUDEBOX_DIR/.claude/commands"
    
    # Only create symlink if commands destination doesn't already exist
    if [[ ! -e "$commands_dest" ]]; then
        # Ensure parent directory exists
        mkdir -p "$PROJECT_CLAUDEBOX_DIR/.claude"
        
        # Create symlink to shared commands
        ln -s "$shared_commands" "$commands_dest"
        
        if [[ "$VERBOSE" == "true" ]]; then
            info "Linked shared commands to project"
        fi
    fi
}
create_build_files() {
    local build_context="$1"

    cat > "$build_context/init-firewall" << 'EOF'
#!/bin/bash
set -euo pipefail
if [ "${DISABLE_FIREWALL:-false}" = "true" ]; then
    echo "Firewall disabled, skipping setup"
    rm -f "$0"
    exit 0
fi
iptables -F OUTPUT 2>/dev/null || true
iptables -F INPUT 2>/dev/null || true
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
iptables -A INPUT -p udp --sport 53 -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -s 127.0.0.0/8 -d 127.0.0.0/8 -j ACCEPT
iptables -A INPUT -s 127.0.0.0/8 -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
# Default allowed domains
DEFAULT_DOMAINS="api.anthropic.com console.anthropic.com statsig.anthropic.com sentry.io"

ALLOWED_DOMAINS="$DEFAULT_DOMAINS"
ALLOWLIST_FILE="/home/DOCKERUSER/.claudebox/projects/${CLAUDEBOX_PROJECT_NAME:-}/allowlist"
if [ -f "$ALLOWLIST_FILE" ]; then
    while IFS= read -r line; do
        [[ "$line" =~ ^#.* ]] && continue
        [[ -z "$line" ]] && continue
        domain="${line#\*.}"
        domain="$(echo "$domain" | xargs)"
        [[ -n "$domain" ]] && ALLOWED_DOMAINS="$ALLOWED_DOMAINS $domain"
    done < "$ALLOWLIST_FILE"
fi

if command -v ipset >/dev/null 2>&1; then
    ipset destroy allowed-domains 2>/dev/null || true
    ipset create allowed-domains hash:net
    ipset destroy allowed-ips 2>/dev/null || true
    ipset create allowed-ips hash:net

    for domain in $ALLOWED_DOMAINS; do
        if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
            ipset add allowed-ips $domain 2>/dev/null || true
        else
            ips=$(getent hosts $domain 2>/dev/null | awk '{print $1}')
            for ip in $ips; do
                ipset add allowed-domains $ip 2>/dev/null || true
            done
        fi
    done
    iptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT
    iptables -A OUTPUT -m set --match-set allowed-ips dst -j ACCEPT
else
    for domain in $ALLOWED_DOMAINS; do
        if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
            iptables -A OUTPUT -d $domain -j ACCEPT
        else
            ips=$(getent hosts $domain 2>/dev/null | awk '{print $1}')
            for ip in $ips; do
                iptables -A OUTPUT -d $ip -j ACCEPT
            done
        fi
    done
fi
iptables -P OUTPUT DROP
iptables -P INPUT DROP
echo "Firewall initialized with Anthropic-only access"
rm -f "$(realpath "$0")"
EOF

    cat > "$build_context/docker-entrypoint.sh" << 'EOF'
#!/bin/bash
set -euo pipefail
ENABLE_SUDO=false
DISABLE_FIREWALL=false
SHELL_MODE=false
new_args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --enable-sudo) ENABLE_SUDO=true; shift ;;
        --disable-firewall) DISABLE_FIREWALL=true; shift ;;
        --shell-mode) SHELL_MODE=true; shift ;;
        *) new_args+=("$1"); shift ;;
    esac
done
set -- "${new_args[@]}"
export DISABLE_FIREWALL

if [ -f ~/init-firewall ]; then
    ~/init-firewall || true
fi

# Handle sudo access based on --enable-sudo flag
# Note: claude user already has sudoers entry from Dockerfile
if [ "$ENABLE_SUDO" != "true" ]; then
    # Remove sudo access if --enable-sudo wasn't passed
    rm -f /etc/sudoers.d/claude
fi

if [ -n "$CLAUDEBOX_PROJECT_NAME" ]; then
    CONFIG_FILE="/home/DOCKERUSER/.claudebox/projects/${CLAUDEBOX_PROJECT_NAME}/config.ini"

    if command -v uv >/dev/null 2>&1 && [ -f "$CONFIG_FILE" ] && grep -qE 'python|ml|datascience' "$CONFIG_FILE"; then
        if [ ! -d /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv ]; then
            su - DOCKERUSER -c "uv venv /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv"
            if [ -f /workspace/pyproject.toml ]; then
                su - DOCKERUSER -c "cd /workspace && uv sync"
            else
                su - DOCKERUSER -c "uv pip install --python /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/python ipython black pylint mypy flake8 pytest ruff"
            fi
        fi

        for shell_rc in /home/DOCKERUSER/.zshrc /home/DOCKERUSER/.bashrc; do
            if ! grep -q "source /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate" "$shell_rc"; then
                echo 'if [ -f /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate ]; then source /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate; fi' >> "$shell_rc"
            fi
        done
    fi
fi

cd /home/DOCKERUSER

if [[ "${SHELL_MODE:-false}" == "true" ]]; then
    # Use runuser to avoid PTY signal handling issues
    exec runuser -u DOCKERUSER -- bash -c "source /home/DOCKERUSER/.nvm/nvm.sh && cd /workspace && exec /bin/zsh"
else
    # Claude mode - handle wrapper logic directly here
    if [[ "${1:-}" == "update" ]]; then
        # Special update handling - pass all arguments
        shift  # Remove "update" from arguments
        exec runuser -u DOCKERUSER -- bash -c '
            export NVM_DIR="$HOME/.nvm"
            if [[ -s "$NVM_DIR/nvm.sh" ]]; then
                \. "$NVM_DIR/nvm.sh"
                nvm use default >/dev/null 2>&1 || {
                    echo "Warning: Failed to activate default Node version" >&2
                }
            else
                echo "Warning: NVM not found at $NVM_DIR" >&2
            fi
            
            cd /workspace
            echo "Running update command..."
            
            # Check for stale update lock (older than 5 minutes)
            lock_file="$HOME/.claude/.update.lock"
            if [[ -f "$lock_file" ]]; then
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_file" 2>/dev/null || stat -c %Y "$lock_file" 2>/dev/null || echo 0) ))
                if [[ $lock_age -gt 300 ]]; then
                    rm -f "$lock_file"
                fi
            fi
            
            # Capture the output of claude update to check if already up to date
            update_output=$(claude update 2>&1)
            echo "$update_output"
            
            # Only run version check if an actual update occurred
            if echo "$update_output" | grep -q "Successfully updated\|Installing update"; then
                echo "Verifying update..."
                claude --version
            fi
        '
    else
        # Regular claude execution
        exec runuser -u DOCKERUSER -- bash -c '
            export NVM_DIR="$HOME/.nvm"
            if [[ -s "$NVM_DIR/nvm.sh" ]]; then
                \. "$NVM_DIR/nvm.sh"
                nvm use default >/dev/null 2>&1 || {
                    echo "Warning: Failed to activate default Node version" >&2
                }
            else
                echo "Warning: NVM not found at $NVM_DIR" >&2
            fi
            
            cd /workspace
            
            # If no arguments and stdin is a terminal, run claude in interactive mode
            if [[ $# -eq 0 ]] && [[ -t 0 ]]; then
                exec claude
            else
                exec claude "$@"
            fi
        ' -- "$@"
    fi
fi
EOF
}

run_docker_build() {
    info "Running docker build..."
    DOCKER_BUILDKIT=1 docker build \
        --build-arg USER_ID="$USER_ID" \
        --build-arg GROUP_ID="$GROUP_ID" \
        --build-arg USERNAME="$DOCKER_USER" \
        --build-arg NODE_VERSION="$NODE_VERSION" \
        --build-arg DELTA_VERSION="$DELTA_VERSION" \
        --build-arg REBUILD_TIMESTAMP="${CLAUDEBOX_REBUILD_TIMESTAMP:-}" \
        -f "$1" -t "$IMAGE_NAME" "$2"
}

main() {
    update_symlink
    local project_folder_name
    project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
    IMAGE_NAME="claudebox-${project_folder_name}"
    local docker_status
    docker_status=$(check_docker; echo $?)
    case $docker_status in
        1) install_docker ;;
        2)
            warn "Docker is installed but not running."
            warn "Starting Docker requires sudo privileges..."
            sudo systemctl start docker
            docker info &>/dev/null || error "Failed to start Docker"
            docker ps &>/dev/null || configure_docker_nonroot
            ;;
        3)
            warn "Docker requires sudo. Setting up non-root access..."
            configure_docker_nonroot
            ;;
    esac

    local args=("$@")
    local new_args=()
    local found_rebuild=false

    for arg in "${args[@]}"; do
        if [[ "$arg" == "rebuild" ]]; then
            found_rebuild=true
        elif [[ "$arg" == "--verbose" ]]; then
            VERBOSE=true
        else
            new_args+=("$arg")
        fi
    done
    
    # Set up project variables early - needed by multiple sections
    local project_folder_name
    project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
    IMAGE_NAME="claudebox-${project_folder_name}"
    PROJECT_CLAUDEBOX_DIR="$HOME/.claudebox/projects/$project_folder_name"

    if [[ "$found_rebuild" == "true" ]]; then
        warn "Rebuilding ClaudeBox Docker image (no cache)..."
        if docker image inspect "$IMAGE_NAME" &>/dev/null; then
            # Remove the specific container for this project
            docker rm -f "$IMAGE_NAME" 2>/dev/null || true
            # Remove any old labeled containers
            docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
        fi
        export CLAUDEBOX_NO_CACHE=true
        set -- "${new_args[@]}"
    fi

    mkdir -p "$PROJECT_CLAUDEBOX_DIR"

    # Check for help flags early - only check first argument
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || "${1:-}" == "help" ]]; then
        show_help
        exit 0
    fi

    [[ "$VERBOSE" == "true" ]] && echo "Command: ${1:-none}" >&2
    
    # First, handle commands that don't require Docker image
    case "${1:-}" in
        profiles)
            shift
            cecho "Available ClaudeBox Profiles:" "$CYAN"
            echo
            for profile in $(get_all_profile_names | tr ' ' '\n' | sort); do
                local desc=$(get_profile_description "$profile")
                echo -e "  ${GREEN}$profile${NC} - $desc"
            done
            exit 0
            ;;

        projects)

            shift
            cecho "ClaudeBox Projects:" "$CYAN"
            echo
            printf "%10s  %s  %s\n" "Size" "🐳" "Path"
            printf "%10s  %s  %s\n" "----" "--" "----"

            if ! list_all_projects; then
                echo
                warn "No ClaudeBox projects found."
                echo
                cecho "Start a new project:" "$GREEN"
                echo "  cd /your/project/directory"
                echo "  claudebox"
            fi
            echo
            exit 0
            ;;

        profile)
            shift

            local project_folder_name
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
            local profile_file
            profile_file=$(get_profile_file_path)

            case "${1:-}" in
                list|--list|-l)

                    cecho "Available ClaudeBox Profiles:" "$CYAN"
                    echo
                    for profile in $(get_all_profile_names | tr ' ' '\n' | sort); do
                        local desc=$(get_profile_description "$profile")
                        echo -e "  ${GREEN}$profile${NC} - $desc"
                    done
                    exit 0
                    ;;

                status|--status|-s)

                    cecho "Project: $PROJECT_DIR" "$CYAN"
                    echo
                    if [[ -f "$profile_file" ]]; then
                        local current_profiles=()
                        readarray -t current_profiles < <(read_profile_section "$profile_file" "profiles")
                        if [[ ${#current_profiles[@]} -gt 0 ]]; then
                            cecho "Active profiles: ${current_profiles[*]}" "$GREEN"
                        else
                            cecho "No profiles installed" "$YELLOW"
                        fi

                        local current_packages=()
                        readarray -t current_packages < <(read_profile_section "$profile_file" "packages")
                        if [[ ${#current_packages[@]} -gt 0 ]]; then
                            echo "Extra packages: ${current_packages[*]}"
                        fi
                    else
                        cecho "No profiles configured for this project" "$YELLOW"
                    fi
                    exit 0
                    ;;

                "")

                    cecho "ClaudeBox Profile Management:" "$CYAN"
                    echo
                    echo -e "  ${GREEN}profiles${NC}                 Show all available profiles"
                    echo -e "  ${GREEN}profile status${NC}           Show current project's profiles"
                    echo -e "  ${GREEN}profile <names...>${NC}       Install profiles (e.g., python c rust)"
                    echo
                    cecho "Examples:" "$YELLOW"
                    echo "  claudebox profiles              # See all available profiles"
                    echo "  claudebox profile status        # Check current project's profiles"
                    echo "  claudebox profile python        # Install Python development profile"
                    echo "  claudebox profile c openwrt     # Install C and OpenWRT profiles"
                    exit 0
                    ;;
            esac

            local selected=() remaining=()
            while [[ $# -gt 0 ]]; do

                if profile_exists "$1"; then
                    selected+=("$1")
                    shift
                else
                    remaining=("$@")
                    break
                fi
            done

            [[ ${#selected[@]} -eq 0 ]] && error "No valid profiles specified\nRun 'claudebox profile' to see available profiles"

            local profile_file
            profile_file=$(get_profile_file_path)


            update_profile_section "$profile_file" "profiles" "${selected[@]}"

            local all_profiles=()
            readarray -t all_profiles < <(read_profile_section "$profile_file" "profiles")

            cecho "Profile: $PROJECT_DIR" "$CYAN"
            cecho "Installing profiles: ${selected[*]}" "$PURPLE"
            if [[ ${#all_profiles[@]} -gt 0 ]]; then
                cecho "All active profiles: ${all_profiles[*]}" "$GREEN"
            fi
            echo

            if [[ ${#remaining[@]} -gt 0 ]]; then
                set -- "${remaining[@]}"
            fi
            ;;
        save)
            shift
            defaults_file="$HOME/.claudebox/default-flags"

            if [[ $# -eq 0 ]]; then
                if [[ -f "$defaults_file" ]]; then
                    rm -f "$defaults_file"
                    success "Cleared saved default flags"
                else
                    info "No saved default flags to clear"
                fi
            else
                mkdir -p "$HOME/.claudebox"
                printf '%s\n' "$@" > "$defaults_file"
                success "Saved default flags: $*"
            fi
            exit 0
                        ;;
        install)
            shift
            [[ $# -eq 0 ]] && error "No packages specified. Usage: claudebox install <package1> <package2> ..."

            local profile_file
            profile_file=$(get_profile_file_path)

            update_profile_section "$profile_file" "packages" "$@"

            local all_packages=()
            readarray -t all_packages < <(read_profile_section "$profile_file" "packages")

            cecho "Profile: $PROJECT_DIR" "$CYAN"
            cecho "Installing packages: $*" "$PURPLE"
            if [[ ${#all_packages[@]} -gt 0 ]]; then
                cecho "All packages: ${all_packages[*]}" "$GREEN"
            fi
            echo
            ;;

        unlink)
            if [[ -L "$LINK_TARGET" ]]; then
                rm -f "$LINK_TARGET"
                success "Removed claudebox symlink from $(dirname "$LINK_TARGET")"
            else
                info "No claudebox symlink found at $LINK_TARGET"
            fi
            exit 0
            ;;

        shell)
            shift
            # Check if image exists first
            if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            local persist_mode=false
            local shell_flags=()
            
            # Check if first arg is "admin"
            if [[ "${1:-}" == "admin" ]]; then
                persist_mode=true
                shift
                # In admin mode, automatically enable sudo and disable firewall
                shell_flags+=("--enable-sudo" "--disable-firewall")
            fi
            
            # Process remaining flags (only for non-persist mode)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --enable-sudo|--disable-firewall)
                        if [[ "$persist_mode" == "false" ]]; then
                            shell_flags+=("$1")
                        fi
                        shift
                        ;;
                    *)
                        warn "Unknown shell flag: $1"
                        shift
                        ;;
                esac
            done

            echo
            logo
            echo
            
            # Run container for shell
            if [[ "$persist_mode" == "true" ]]; then
                cecho "Administration Mode" "$YELLOW"
                echo "Sudo enabled, firewall disabled."
                echo "Changes will be saved to the image when you exit."
                echo
                
                # Create a named container for admin mode so we can commit it
                local project_folder_name
                project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
                local temp_container="claudebox-shell-${project_folder_name}-$$"
                
                # Ensure cleanup runs on any exit (including Ctrl-C)
                cleanup_admin() {
                    docker commit "$temp_container" "$IMAGE_NAME" >/dev/null 2>&1
                    docker rm -f "$temp_container" >/dev/null 2>&1
                }
                trap cleanup_admin EXIT
                
                run_claudebox_container "$temp_container" "interactive" --shell-mode "${shell_flags[@]}"
                
                # Commit changes back to image
                fillbar
                docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
                docker rm -f "$temp_container" >/dev/null 2>&1
                fillbar stop
                success "Changes saved to image!"
            else
                # Regular shell mode - just run without committing
                run_claudebox_container "" "interactive" --shell-mode "${shell_flags[@]}"
            fi
            
            exit 0
            ;;

        update)
            # Handle update all specially
            if [[ "${2:-}" == "all" ]]; then
                info "Updating all components..."
                echo
                
                # Update claudebox script
                info "Updating claudebox script..."
                if command -v curl >/dev/null 2>&1; then
                    curl -fsSL https://raw.githubusercontent.com/RchGrav/claudebox/main/claudebox -o /tmp/claudebox.new
                elif command -v wget >/dev/null 2>&1; then
                    wget -qO /tmp/claudebox.new https://raw.githubusercontent.com/RchGrav/claudebox/main/claudebox
                else
                    error "Neither curl nor wget found"
                fi
                
                if [[ -f /tmp/claudebox.new ]]; then
                    # Find the installed claudebox (not the source)
                    local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
                    
                    # If it's a symlink, replace it with the actual file first
                    if [[ -L "$installed_path" ]]; then
                        info "Converting symlink to real file..."
                        local source_file=$(readlink -f "$installed_path")
                        if [[ -w "$(dirname "$installed_path")" ]]; then
                            cp "$source_file" "$installed_path.tmp"
                            mv "$installed_path.tmp" "$installed_path"
                            chmod +x "$installed_path"
                        else
                            sudo cp "$source_file" "$installed_path.tmp"
                            sudo mv "$installed_path.tmp" "$installed_path"
                            sudo chmod +x "$installed_path"
                        fi
                    fi
                    
                    # Compare hashes of the INSTALLED file
                    current_hash=$(sha256sum "$installed_path" 2>/dev/null | cut -d" " -f1 || echo "none")
                    new_hash=$(sha256sum /tmp/claudebox.new | cut -d" " -f1)
                    
                    if [[ "$current_hash" != "$new_hash" ]]; then
                        info "New version available, updating..."
                        
                        # Backup current installed version
                        local backups_dir="$HOME/.claudebox/backups"
                        mkdir -p "$backups_dir"
                        local timestamp=$(date +%s)
                        cp "$installed_path" "$backups_dir/$timestamp"
                        info "Backed up current version to $backups_dir/$timestamp"
                        
                        # Update the INSTALLED file
                        if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                            cp /tmp/claudebox.new "$installed_path"
                            chmod +x "$installed_path"
                        else
                            sudo cp /tmp/claudebox.new "$installed_path"
                            sudo chmod +x "$installed_path"
                        fi
                        success "✓ Claudebox script updated at $installed_path"
                    else
                        success "✓ Claudebox script already up to date"
                    fi
                    rm -f /tmp/claudebox.new
                fi
                echo
                
                # Update commands
                info "Updating commands..."
                local commands_dir="$HOME/.claudebox/commands"
                mkdir -p "$commands_dir"
                
                for cmd in taskengine devops; do
                    echo -n "  Updating $cmd.md... "
                    if command -v curl >/dev/null 2>&1; then
                        curl -fsSL "https://raw.githubusercontent.com/RchGrav/claudebox/main/commands/$cmd.md" -o "$commands_dir/$cmd.md"
                    else
                        wget -qO "$commands_dir/$cmd.md" "https://raw.githubusercontent.com/RchGrav/claudebox/main/commands/$cmd.md"
                    fi
                    echo "✓"
                done
                echo
                
                # Now update Claude
                info "Updating Claude..."
                shift # Remove "update"
                shift # Remove "all"
                set -- "update" "$@" # Put back just "update"
            fi
            
            # Check if image exists first
            if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            # Continue with normal update flow
            ;&  # Fall through to next case
            
        config|mcp|migrate-installer)
            # Check if image exists first (for non-update commands)
            if [[ "$1" != "update" ]] && ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            # Create temporary container
            local temp_container="claudebox-temp-${project_folder_name}-$$"
            
            # Run container with all arguments passed through
            run_claudebox_container "$temp_container" "detached" "$@" >/dev/null
            
            # Show progress while waiting
            if [[ "$1" == "update" ]]; then
                # Show hint during update
                echo
                cecho "Hint:" "$YELLOW"
                echo "  claudebox update all            # Pull the latest claudebox features!"
                echo
            fi
            fillbar
            
            # Wait for container to finish
            docker wait "$temp_container" >/dev/null
            
            fillbar stop
            
            # Show container output for commands that produce output
            docker logs "$temp_container" 2>&1
            
            # For update command, show version after update
            if [[ "$1" == "update" ]]; then
                docker exec -u "$DOCKER_USER" "$temp_container" bash -c "
                    source \$HOME/.nvm/nvm.sh && nvm use default >/dev/null 2>&1 && claude --version
                " 2>/dev/null || true
            fi

            # Commit changes back to image
            docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
            docker stop "$temp_container" >/dev/null 2>&1 || true
            docker rm "$temp_container" >/dev/null 2>&1 || true
            
            exit 0
            ;;

        allowlist)
            shift
            local allowlist_file="$PROJECT_CLAUDEBOX_DIR/allowlist"

            cecho "🔒 ClaudeBox Firewall Allowlist" "$CYAN"
            echo
            cecho "Current Project: $PROJECT_DIR" "$WHITE"
            echo

            if [[ -f "$allowlist_file" ]]; then
                cecho "Allowlist file:" "$GREEN"
                echo "  $allowlist_file"
                echo
                cecho "Allowed domains:" "$CYAN"
                # Display allowlist contents
                while IFS= read -r line; do
                    if [[ -n "$line" ]] && [[ ! "$line" =~ ^#.* ]]; then
                        echo "  $line"
                    fi
                done < "$allowlist_file"
                echo
            else
                cecho "Allowlist file:" "$YELLOW"
                echo "  Not yet created (will be created on first run)"
                echo "  Location: $allowlist_file"
            fi

            echo
            cecho "Default Allowed Domains:" "$CYAN"
            echo "  api.anthropic.com, console.anthropic.com, statsig.anthropic.com, sentry.io"
            echo
            cecho "To edit allowlist:" "$YELLOW"
            echo "  \$EDITOR $allowlist_file"
            echo
            cecho "Note:" "$WHITE"
            echo "  Changes take effect on next container start"
            echo "  Use --disable-firewall flag to bypass all restrictions"

            exit 0
            ;;

        clean)
            shift
            case "${1:-}" in
                all)
                    warn "Complete Docker cleanup: removing all claudebox containers, images, volumes, and cache..."
                    # Remove all claudebox containers
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    docker ps -a --format "{{.Names}}" | grep "^claudebox-" | xargs -r docker rm -f 2>/dev/null || true

                    # Remove ALL claudebox images (including base)
                    docker images --filter "reference=claudebox-*" -q | xargs -r docker rmi -f 2>/dev/null || true
                    docker images --filter "reference=claudebox" -q | xargs -r docker rmi -f 2>/dev/null || true

                    # Remove dangling images
                    docker images -f "dangling=true" -q | xargs -r docker rmi -f 2>/dev/null || true

                    # Prune build cache
                    docker builder prune -af 2>/dev/null || true

                    # Remove volumes
                    docker volume ls -q --filter "name=claudebox" | xargs -r docker volume rm 2>/dev/null || true

                    success "Docker cleanup complete!"
                    ;;
                image)
                    warn "Removing ClaudeBox containers and image..."
                    # Remove any containers from this image
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    # Remove orphaned containers from images that no longer exist
                    # This is safer as it only removes containers whose images are gone
                    docker ps -a --filter "status=exited" --format "{{.ID}} {{.Image}}" | while read id image; do
                        if ! docker image inspect "$image" >/dev/null 2>&1; then
                            docker rm -f "$id" 2>/dev/null || true
                        fi
                    done
                   # Remove all claudebox project images
                   docker images --filter "reference=claudebox-*" -q | xargs -r docker rmi -f 2>/dev/null || true
                    docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
                    success "Containers and image removed! Build cache preserved."
                    ;;
                cache)
                    warn "Cleaning Docker build cache..."
                    docker builder prune -af
                    success "Build cache cleaned!"
                    ;;
                volumes)
                    warn "Removing ClaudeBox-related volumes..."
                    docker volume ls -q --filter "name=claudebox" | xargs -r docker volume rm 2>/dev/null || true
                    docker volume prune -f 2>/dev/null || true
                    success "Volumes cleaned!"
                    ;;
                containers)
                    warn "Cleaning ClaudeBox containers..."
                    # Remove any containers from this image
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    # Remove orphaned containers from images that no longer exist
                    # This is safer as it only removes containers whose images are gone
                    docker ps -a --filter "status=exited" --format "{{.ID}} {{.Image}}" | while read id image; do
                        if ! docker image inspect "$image" >/dev/null 2>&1; then
                            docker rm -f "$id" 2>/dev/null || true
                        fi
                    done
                    success "Containers cleaned!"
                    ;;
                dangling)
                    warn "Removing dangling images and unused containers..."
                    docker image prune -f
                    docker container prune -f
                    success "Dangling resources cleaned!"
                    ;;
                logs)
                    warn "Clearing Docker container logs..."
                    docker ps -a --filter "label=claudebox.project" -q | while read -r container; do
                        docker logs "$container" >/dev/null 2>&1 && echo -n | docker logs "$container" 2>/dev/null || true
                    done
                    success "Container logs cleared!"
                    ;;
                project)
                    shift

                    local target_path="$PROJECT_DIR"
                    local project_folder_name

                    if [[ $# -gt 0 ]] && [[ "${1:0:1}" != "-" ]] && [[ "$1" != "all" && "$1" != "data" && "$1" != "docker" && "$1" != "profiles" && "$1" != "tools" ]]; then
                        target_path="$1"
                        shift

                        project_folder_name=$(resolve_project_path "$target_path")
                        if [[ -z "$project_folder_name" ]]; then
                            error "No ClaudeBox project found at: $target_path"
                        fi
                    else
                        project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
                    fi

                    local project_claudebox_dir="$HOME/.claudebox/projects/$project_folder_name"
                    local image_name="claudebox-${project_folder_name}"

                    local display_path="$PROJECT_DIR"
                    local config_file="$project_claudebox_dir/config.ini"
                    if [[ -f "$config_file" ]]; then
                        local path_value=$(read_config_value "$config_file" "project" "path")
                        [[ -n "$path_value" ]] && display_path="$path_value"
                    fi

                    case "${1:-}" in
                        profiles|tools)
                            warn "Clearing profile configuration for: $display_path"
                            if [[ -f "$config_file" ]]; then

                                {
                                    awk '/^\[profiles\]/ { profiles=1; print; print ""; next }
                                         /^\[packages\]/ { packages=1; print; print ""; next }
                                         /^\[/ { profiles=0; packages=0 }
                                         !profiles && !packages { print }' "$config_file"
                                } > "${config_file}.tmp" && mv "${config_file}.tmp" "$config_file"
                                success "Cleared profile configuration"
                            else
                                info "No configuration file found"
                            fi
                            ;;
                        data)
                            warn "Removing project data for: $display_path"
                            if [[ -d "$project_claudebox_dir" ]]; then
                                rm -rf "$project_claudebox_dir"
                                success "Removed project data folder: $project_claudebox_dir"
                            else
                                info "No project data folder found"
                            fi
                            ;;
                        docker)
                            warn "Removing Docker image for: $display_path"
                            docker rmi -f "$image_name" 2>/dev/null && \
                                success "Removed Docker image: $image_name" || \
                                info "No Docker image found for this project"
                            ;;
                        all)
                            warn "Removing all project artifacts for: $display_path"
                            if [[ -f "$config_file" ]]; then
                                rm -f "$config_file"
                                success "Removed profile configuration"
                            fi
                            if [[ -d "$project_claudebox_dir" ]]; then
                                rm -rf "$project_claudebox_dir"
                                success "Removed project data folder"
                            fi
                            docker rmi -f "$image_name" 2>/dev/null && \
                                success "Removed Docker image" || \
                                info "No Docker image found"
                            ;;
                        *)
                            cecho "ClaudeBox Project Clean Options:" "$CYAN"
                            echo
                            echo -e "  ${GREEN}clean project [path] profiles${NC}   Remove installed profiles & packages"
                            echo -e "  ${GREEN}clean project [path] data${NC}       Remove project data (auth, history, configs)"
                            echo -e "  ${GREEN}clean project [path] docker${NC}     Remove project Docker image"
                            echo -e "  ${GREEN}clean project [path] all${NC}        Remove everything for this project"
                            echo
                            cecho "Usage examples:" "$WHITE"
                            echo "  claudebox clean project data                      # Current directory"
                            echo "  claudebox clean project /path/to/project all      # Specific path"
                            echo
                            cecho "Current project: $PROJECT_DIR" "$YELLOW"
                            echo
                            cecho "What gets removed:" "$WHITE"
                            echo "  profiles: Clears [profiles] and [packages] sections in config.ini"
                            echo "  data:     ~/.claudebox/projects/${project_folder_name}/ (entire project folder)"
                            echo "  docker:   Docker image claudebox-${project_folder_name}"
                            exit 0
                            ;;
                    esac
                    exit 0
                    ;;
                *)
                    cecho "ClaudeBox Clean Options:" "$CYAN"
                    echo
                    echo -e "  ${GREEN}clean containers${NC}         Remove all containers (preserves image)"
                    echo -e "  ${GREEN}clean project${NC}            Show project cleanup options"
                    echo -e "  ${GREEN}clean all${NC}                Remove all Docker artifacts (containers, images, cache, volumes)"
                    echo -e "  ${GREEN}clean image${NC}              Remove containers and image (preserves build cache)"
                    echo -e "  ${GREEN}clean cache${NC}              Remove Docker build cache only"
                    echo -e "  ${GREEN}clean volumes${NC}            Remove associated Docker volumes"
                    echo -e "  ${GREEN}clean dangling${NC}           Remove dangling images and unused containers"
                    echo -e "  ${GREEN}clean logs${NC}               Clear Docker container logs"
                    echo
                    cecho "Examples:" "$YELLOW"
                    echo "  claudebox clean containers  # Remove all containers"
                    echo "  claudebox clean project     # Show project cleanup menu"
                    echo "  claudebox clean image       # Remove containers and image"
                    echo "  claudebox clean all         # Complete Docker cleanup"
                    exit 0
                    ;;
            esac
            echo
            docker system df
            exit 0
            ;;


        undo)
            local backups_dir="$HOME/.claudebox/backups"
            if [[ ! -d "$backups_dir" ]] || [[ -z "$(ls -A "$backups_dir" 2>/dev/null)" ]]; then
                error "No backups found"
            fi
            
            # Get oldest backup (smallest timestamp)
            local oldest=$(ls -1 "$backups_dir" | sort -n | head -1)
            local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
            
            info "Restoring oldest backup from $(date -d @$oldest '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r $oldest '+%Y-%m-%d %H:%M:%S')"
            
            if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                cp "$backups_dir/$oldest" "$installed_path"
                chmod +x "$installed_path"
            else
                sudo cp "$backups_dir/$oldest" "$installed_path"
                sudo chmod +x "$installed_path"
            fi
            
            success "✓ Restored claudebox from backup"
            exit 0
            ;;
            
        redo)
            local backups_dir="$HOME/.claudebox/backups"
            if [[ ! -d "$backups_dir" ]] || [[ -z "$(ls -A "$backups_dir" 2>/dev/null)" ]]; then
                error "No backups found"
            fi
            
            # Get newest backup (largest timestamp)
            local newest=$(ls -1 "$backups_dir" | sort -n | tail -1)
            local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
            
            info "Restoring newest backup from $(date -d @$newest '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r $newest '+%Y-%m-%d %H:%M:%S')"
            
            if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                cp "$backups_dir/$newest" "$installed_path"
                chmod +x "$installed_path"
            else
                sudo cp "$backups_dir/$newest" "$installed_path"
                sudo chmod +x "$installed_path"
            fi
            
            success "✓ Restored claudebox from backup"
            exit 0
            ;;

        help)
            show_help
            exit 0
            ;;

        info)
            shift
            # Compute project folder name early for paths
            local project_folder_name
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
            IMAGE_NAME="claudebox-${project_folder_name}"
            PROJECT_CLAUDEBOX_DIR="$HOME/.claudebox/projects/$project_folder_name"

            cecho "╔═══════════════════════════════════════════════════════════════════╗" "$CYAN"
            cecho "║                    ClaudeBox Information Panel                    ║" "$CYAN"
            cecho "╚═══════════════════════════════════════════════════════════════════╝" "$CYAN"
            echo

            # Current Project Info
            cecho "📁 Current Project" "$WHITE"
            echo "   Path:       $PROJECT_DIR"
            echo "   Project ID: $project_folder_name"
            echo "   Data Dir:   $PROJECT_CLAUDEBOX_DIR"
            echo

            # ClaudeBox Installation
            cecho "📦 ClaudeBox Installation" "$WHITE"
            echo "   Script:  $SCRIPT_PATH"
            echo "   Symlink: $LINK_TARGET"
            echo

            # Saved CLI Flags
            cecho "🚀 Saved CLI Flags" "$WHITE"
            if [[ -f "$HOME/.claudebox/default-flags" ]]; then
                local saved_flags=()
                while IFS= read -r flag; do
                    [[ -n "$flag" ]] && saved_flags+=("$flag")
                done < "$HOME/.claudebox/default-flags"
                if [[ ${#saved_flags[@]} -gt 0 ]]; then
                    echo -e "   Flags: ${GREEN}${saved_flags[*]}${NC}"
                else
                    echo -e "   ${YELLOW}No flags saved${NC}"
                fi
            else
                echo -e "   ${YELLOW}No saved flags${NC}"
            fi
            echo


            # Claude Commands
            cecho "📝 Claude Commands" "$WHITE"
            local cmd_count=0
            if [[ -d "$HOME/.claudebox/commands" ]]; then
                cmd_count=$(ls -1 "$HOME/.claudebox/commands"/*.md 2>/dev/null | wc -l)
            fi
            local project_cmd_count=0
            if [[ -d ".claude/commands" ]]; then
                project_cmd_count=$(ls -1 .claude/commands/*.md 2>/dev/null | wc -l)
            fi

            if [[ $cmd_count -gt 0 ]] || [[ $project_cmd_count -gt 0 ]]; then
                echo "   Global:  $cmd_count command(s)"
                if [[ $cmd_count -gt 0 ]] && [[ -d "$HOME/.claudebox/commands" ]]; then
                    for cmd_file in "$HOME/.claudebox/commands"/*.md; do
                        [[ -f "$cmd_file" ]] || continue
                        echo "            - $(basename "$cmd_file" .md)"
                    done
                fi
                echo "   Project: $project_cmd_count command(s)"
                if [[ $project_cmd_count -gt 0 ]] && [[ -d ".claude/commands" ]]; then
                    for cmd_file in .claude/commands/*.md; do
                        [[ -f "$cmd_file" ]] || continue
                        echo "            - $(basename "$cmd_file" .md)"
                    done
                fi
            else
                echo -e "   ${YELLOW}No custom commands found${NC}"
                echo -e "   Location: ~/.claudebox/commands/ (global), .claude/commands/ (project)"
            fi
            echo

            # Project Profiles
            cecho "🛠️ Project Profiles& & Packages" "$WHITE"
            local current_profile_file
            current_profile_file=$(get_profile_file_path)
            if [[ -f "$current_profile_file" ]]; then
                local current_profiles=()
                readarray -t current_profiles < <(read_profile_section "$current_profile_file" "profiles")
                local current_packages=()
                readarray -t current_packages < <(read_profile_section "$current_profile_file" "packages")

                if [[ ${#current_profiles[@]} -gt 0 ]]; then
                    echo -e "   Installed:  ${GREEN}${current_profiles[*]}${NC}"
                else
                    echo -e "   Installed:  ${YELLOW}None${NC}"
                fi

                if [[ ${#current_packages[@]} -gt 0 ]]; then
                    echo "   Packages:   ${current_packages[*]}"
                fi
            else
                echo -e "   Status:     ${YELLOW}No profiles installed${NC}"
            fi

            echo -e "   Available:  ${CYAN}core${NC}, python, c, rust, go, javascript, java, ruby, php"
            echo -e "               database, devops, web, ml, security, embedded, networking"
            echo -e "   ${CYAN}Hint:${NC} Run 'claudebox profile' for profile help "
            echo

            cecho "🐳 Docker Status" "$WHITE"
            if docker image inspect "$IMAGE_NAME" &>/dev/null; then
                local image_info=$(docker images --filter "reference=$IMAGE_NAME" --format "{{.Size}}")
                echo -e "   Image:      ${GREEN}Ready${NC} ($IMAGE_NAME - $image_info)"

                local image_created=$(docker inspect "$IMAGE_NAME" --format '{{.Created}}' | cut -d'T' -f1)
                local layer_count=$(docker history "$IMAGE_NAME" --no-trunc --format "{{.CreatedBy}}" | wc -l)
                echo "   Created:    $image_created"
                echo "   Layers:     $layer_count"
            else
                echo -e "   Image:      ${YELLOW}Not built${NC}"
            fi

            local running_containers=$(docker ps --filter "ancestor=$IMAGE_NAME" -q 2>/dev/null)
            if [[ -n "$running_containers" ]]; then
                local container_count=$(echo "$running_containers" | wc -l)
                echo -e "   Containers: ${GREEN}$container_count running${NC}"

                for container_id in $running_containers; do
                    local container_stats="$(docker stats --no-stream --format "{{.Container}}: {{.CPUPerc}} CPU, {{.MemUsage}}" "$container_id" 2>/dev/null || echo "")"
                    if [[ -n "$container_stats" ]]; then
                        echo "               - $container_stats"
                    fi
                done
            else
                echo "   Containers: None running"
            fi
            echo

            # All Projects Summary
            cecho "📊 All Projects Summary" "$WHITE"
            local total_projects=$(ls -1d "$HOME/.claudebox/projects"/*/ 2>/dev/null | wc -l)
            echo "   Projects:   $total_projects total"

            local total_size=$(docker images --filter "reference=claudebox-*" --format "{{.Size}}" | awk '{
                size=$1; unit=$2;
                if (unit == "GB") size = size * 1024;
                else if (unit == "KB") size = size / 1024;
                total += size
            } END {
                if (total > 1024) printf "%.1fGB", total/1024;
                else printf "%.1fMB", total
            }')
            local image_count=$(docker images --filter "reference=claudebox-*" -q | wc -l)
            echo "   Images:     $image_count ClaudeBox images using $total_size"

            local docker_stats=$(docker system df --format "table {{.Type}}\t{{.Total}}\t{{.Active}}\t{{.Size}}\t{{.Reclaimable}}" 2>/dev/null | tail -n +2)
            if [[ -n "$docker_stats" ]]; then
                echo "   System:"
                while IFS=$'\t' read -r type total active size reclaim; do
                    echo "               - $type: $total total, $active active ($size, $reclaim reclaimable)"
                done <<< "$docker_stats"
            fi
            echo

            exit 0
            ;;

    esac
    
    # Check if Docker image is needed and exists (skip if rebuilding)
    case "${1:-}" in
        shell|update|config|mcp|migrate-installer)
            # These commands need Docker image
            if [[ "${CLAUDEBOX_NO_CACHE:-}" != "true" ]] && [[ ! -f /.dockerenv ]] && ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
                error "ClaudeBox image not found.\nRun ${GREEN}claudebox${NC} first to build the image."
            fi
            ;;
    esac
    
    # Now handle Docker-requiring commands
    case "${1:-}" in
        shell)
            # Shell command was already handled above - this line makes case complete
            # The implementation is already in place
            ;;
            
        update|config|mcp|migrate-installer)
            # These commands were already handled above - this line makes case complete
            # The implementation is already in place
            ;;
            
        *)
            # Default case - continue to setup and run claude
            ;;
    esac

    # Ensure shared commands folder is set up
    setup_shared_commands
    
    setup_project_folder
    setup_claude_agent_command

    local need_rebuild=false
    local current_profiles=()
    local profile_hash=""

    local config_file="$PROJECT_CLAUDEBOX_DIR/config.ini"
    if [[ -f "$config_file" ]]; then
        readarray -t current_profiles < <(read_profile_section "$config_file" "profiles")
        local cleaned_profiles=()
        for profile in "${current_profiles[@]}"; do
            profile=$(echo "$profile" | tr -d '[:space:]')
            [[ -z "$profile" ]] && continue
            cleaned_profiles+=("$profile")
        done
        current_profiles=("${cleaned_profiles[@]}")

        if [[ ${#current_profiles[@]} -gt 0 ]]; then
            profile_hash=$(printf '%s\n' "${current_profiles[@]}" | sort | sha256sum | cut -d' ' -f1)
        fi
    fi

    # Calculate hash of the script itself
    local script_hash=$(sha256sum "$SCRIPT_PATH" | cut -d' ' -f1)
    local build_hash="${script_hash}-${profile_hash}"
    
    # Check if build files have changed
    local last_build_hash_file="$HOME/.claudebox/.last_build_hash"
    if [[ -f "$last_build_hash_file" ]]; then
        local last_build_hash=$(cat "$last_build_hash_file")
        if [[ "$build_hash" != "$last_build_hash" ]]; then
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
            need_rebuild=true
        fi
    else
        # No hash file means first run or deleted, trigger rebuild
        need_rebuild=true
    fi

    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then

        local image_profile_hash
        image_profile_hash=$(docker inspect "$IMAGE_NAME" --format '{{index .Config.Labels "claudebox.profiles"}}' 2>/dev/null || echo "")

        if [[ "$profile_hash" != "$image_profile_hash" ]]; then
            if [[ ${#current_profiles[@]} -gt 0 ]]; then
                info "Building with profiles: ${current_profiles[*]}"
            fi
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
            need_rebuild=true
        fi
    else
        need_rebuild=true
    fi

        if [[ "$need_rebuild" == "true" ]] || ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                logo
                local build_context="$HOME/.claudebox/build"
                mkdir -p "$build_context"
                local dockerfile="$build_context/Dockerfile"

        create_build_files "$build_context"

    info "Using git-delta version: $DELTA_VERSION"

        cat > "$dockerfile" <<'DOCKERFILE'
FROM debian:bookworm
ARG USER_ID GROUP_ID USERNAME NODE_VERSION DELTA_VERSION
ARG REBUILD_TIMESTAMP

RUN echo '#!/bin/sh\nexit 101' > /usr/sbin/policy-rc.d && chmod +x /usr/sbin/policy-rc.d

RUN export DEBIAN_FRONTEND=noninteractive && \
    apt-get update && \
        apt-get install -y --no-autoremove --no-install-recommends ca-certificates curl locales gnupg && apt-get clean && \
    echo "en_US.UTF-8 UTF-8" > /etc/locale.gen && locale-gen en_US.UTF-8 &&\
        mkdir -p /usr/share/keyrings && \
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg -o /tmp/githubcli.gpg && \
        cat /tmp/githubcli.gpg | gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg && \
        rm -f /tmp/githubcli.gpg && \
    chmod 644 /usr/share/keyrings/githubcli-archive-keyring.gpg && \
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg]" \
    "https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null && apt-get update && \
        apt-get install -y --no-autoremove --no-install-recommends apt-utils wget zsh fzf ca-certificates sudo git iptables ipset gh unzip jq \
        procps vim nano less iputils-ping traceroute dnsutils netcat-openbsd net-tools xdg-utils && \
        rm -rf /var/lib/apt/lists/*

ENV LANG=en_US.UTF-8 \
    LANGUAGE=en_US:en \
    LC_ALL=en_US.UTF-8

RUN groupadd -g $GROUP_ID $USERNAME || true && \
    useradd -m -u $USER_ID -g $GROUP_ID -s /bin/bash $USERNAME

RUN ARCH=$(dpkg --print-architecture) && \
    wget -q https://github.com/dandavison/delta/releases/download/${DELTA_VERSION}/git-delta_${DELTA_VERSION}_${ARCH}.deb && \
    dpkg -i git-delta_${DELTA_VERSION}_${ARCH}.deb && \
    rm git-delta_${DELTA_VERSION}_${ARCH}.deb

USER $USERNAME
WORKDIR /home/$USERNAME

RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.2.0/zsh-in-docker.sh)" -- \
    -p git \
    -p fzf \
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
    -a "source /usr/share/doc/fzf/examples/completion.zsh" \
    -a 'export HISTFILE="/home/$USERNAME/.cache/zsh_history"' \
    -a 'export HISTSIZE=10000' \
    -a 'export SAVEHIST=10000' \
    -a 'setopt HIST_IGNORE_DUPS' \
    -a 'setopt SHARE_HISTORY' \
    -a 'setopt HIST_FCNTL_LOCK' \
    -a 'setopt APPEND_HISTORY' \
    -a 'export NVM_DIR="$HOME/.nvm"' \
    -a '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' \
    -a '[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"' \
    -x

RUN curl -LsSf https://astral.sh/uv/install.sh | sh

RUN echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc && \
    echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc

RUN git config --global core.pager delta && \
    git config --global interactive.diffFilter "delta --color-only" && \
    git config --global delta.navigate true && \
    git config --global delta.light false && \
    git config --global delta.side-by-side true

ENV DEVCONTAINER=true

ENV SHELL=/bin/zsh

ENV NVM_DIR="/home/$USERNAME/.nvm"
RUN curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

RUN bash -c "source $NVM_DIR/nvm.sh && \
    if [[ \"$NODE_VERSION\" == '--lts' ]]; then \
        nvm install --lts && \
        nvm alias default 'lts/*'; \
    else \
        nvm install $NODE_VERSION && \
        nvm alias default $NODE_VERSION; \
    fi && \
    nvm use default"

RUN echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc && \
    echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> ~/.bashrc && \
    echo '[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"' >> ~/.bashrc

RUN bash -c "source $NVM_DIR/nvm.sh && \
    nvm use default && \
    npm install -g @anthropic-ai/claude-code"

RUN cat >> ~/.zshrc <<'EOF'

if [[ -n "$PS1" ]] && command -v stty >/dev/null; then
  function _update_size {
    local rows cols
    { stty size } 2>/dev/null | read rows cols
    ((rows)) && export LINES=$rows COLUMNS=$cols
  }
  TRAPWINCH() { _update_size }
  _update_size
fi
EOF

RUN echo "shopt -s checkwinsize" >> ~/.bashrc

RUN cat > ~/.tmux.conf <<'EOF'

set -g aggressive-resize on

set -g default-terminal "screen-256color"
set -ga terminal-overrides ",xterm-256color:Tc"

set -g mouse on
set -g history-limit 10000
EOF

USER root

# Add sudoers entry for claude user (following Anthropic's model)
RUN echo "claude ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/claude && \
    chmod 0440 /etc/sudoers.d/claude

RUN cat > /etc/profile.d/00-winsize.sh <<'EOF'
if [ -n "$PS1" ] && command -v stty >/dev/null 2>&1; then
  _update_size() {
    local sz
    sz=$(stty size 2>/dev/null) || return
    export LINES=${sz%% *}  COLUMNS=${sz##* }
  }
  trap _update_size WINCH
  _update_size
fi
EOF
DOCKERFILE
        if [[ ${#current_profiles[@]} -gt 0 ]]; then
                info "Building with profiles: ${current_profiles[*]}"

                resolved_profiles=()
                for profile in "${current_profiles[@]}"; do
                        resolved_profiles+=($(expand_profile "$profile"))
                done

                unique_profiles=($(awk -v RS=' ' '!seen[$1]++' <<< "${resolved_profiles[*]}"))

                for profile in "${unique_profiles[@]}"; do
                        # Convert space-separated package string to array
                        local packages=$(get_profile_packages "$profile")
                        IFS=' ' read -ra pkg_list <<< "$packages"
                        
                        # Only add apt install section if there are packages
                        if [[ ${#pkg_list[@]} -gt 0 ]]; then
        cat >> "$dockerfile" <<DOCKERFILE
# $(get_profile_description "$profile")
RUN export DEBIAN_FRONTEND=noninteractive && \\
        apt-get update && \\
        apt-get install -y --no-autoremove ${pkg_list[*]} && \\
        apt-get clean && rm -rf /var/lib/apt/lists/*
DOCKERFILE
                        fi
                        
                        # Always check for special installation steps
                        case "$profile" in
                                        rust)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y && \
        echo 'source $HOME/.cargo/env' >> ~/.bashrc && \
        echo 'source $HOME/.cargo/env' >> ~/.zshrc && \
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc && \
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.zshrc
USER root
DOCKERFILE
                                                ;;
                                        go)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
RUN GO_VERSION="1.21.5" && \
        wget -q "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" && \
        tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz" && \
        rm "go${GO_VERSION}.linux-amd64.tar.gz" && \
        echo 'export PATH=$PATH:/usr/local/go/bin' >> /etc/profile.d/go.sh
DOCKERFILE
                                                ;;
                                        python)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install ipython black mypy pylint pytest ruff poetry pipenv
USER root
DOCKERFILE
                                                ;;
                                        ml)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install torch transformers scikit-learn numpy pandas matplotlib
USER root
DOCKERFILE
                                                ;;
                                        datascience)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install jupyter notebook jupyterlab numpy pandas scipy matplotlib seaborn scikit-learn statsmodels plotly
USER root
DOCKERFILE
                                                ;;
                                        javascript)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN bash -c "source \$NVM_DIR/nvm.sh && npm install -g typescript eslint prettier yarn pnpm"
USER root
DOCKERFILE
                                                ;;
                                        *) : ;;
                                esac
                        done
                fi

        # Add label with profile hash
        echo "# Label the image with the profile hash for change detection" >> "$dockerfile"
        echo "LABEL claudebox.profiles=\"$profile_hash\"" >> "$dockerfile"
        echo "LABEL claudebox.project=\"$project_folder_name\"" >> "$dockerfile"
        echo "" >> "$dockerfile"
        cat >> "$dockerfile" <<'DOCKERFILE'

# Copy init-firewall script
COPY --chmod=755 init-firewall /home/$USERNAME/init-firewall
RUN chown $USERNAME:$USERNAME /home/$USERNAME/init-firewall

USER $USERNAME
RUN bash -c "source $NVM_DIR/nvm.sh && claude --version"

WORKDIR /workspace
USER root
COPY --chown=$USERNAME docker-entrypoint.sh /usr/local/bin/docker-entrypoint
RUN sed -i "s/DOCKERUSER/$USERNAME/g" /usr/local/bin/docker-entrypoint && \
    sed -i "s/DOCKERUSER/$USERNAME/g" /home/$USERNAME/init-firewall && \
    chmod +x /usr/local/bin/docker-entrypoint

ENTRYPOINT ["/usr/local/bin/docker-entrypoint"]
DOCKERFILE

        run_docker_build "$dockerfile" "$build_context"

        # Save build hash for next run
        mkdir -p "$HOME/.claudebox"
        echo "$build_hash" > "$last_build_hash_file"

        echo
        cecho "ClaudeBox Setup Complete!" "$CYAN"
        echo
        cecho "Quick Start:" "$GREEN"
        echo -e "  ${YELLOW}claudebox [options]${NC}        # Launch Claude CLI"
        echo
        cecho "Power Features:" "$GREEN"
        echo -e "  ${YELLOW}claudebox profiles${NC}               # See all available profiles"
        echo -e "  ${YELLOW}claudebox profile c openwrt${NC}      # Install C + OpenWRT tools"
        echo -e "  ${YELLOW}claudebox profile python ml${NC}      # Install Python + ML stack"
        echo -e "  ${YELLOW}claudebox install <packages>${NC}     # Install additional apt packages"
        echo -e "  ${YELLOW}claudebox shell${NC}                  # Open powerline shell in container"
        echo -e "  ${YELLOW}claudebox allowlist${NC}              # View firewall configuration"
        echo
        cecho "Security:" "$GREEN"
        echo -e "  Network firewall: ON by default (Anthropic recommended)"
        echo -e "  Sudo access: OFF by default"
        echo
        cecho "Maintenance:" "$GREEN"
        echo -e "  ${YELLOW}claudebox clean ${NC}                 # See all cleanup options"
        echo -e "  ${YELLOW}claudebox unlink ${NC}                # Remove symbolic link"
        echo
        cecho "Just install the profile you need and start coding!" "$PURPLE"
       exit 0
   fi

   # Run container

   # Ensure .claudebox exists with proper permissions
   if [[ ! -d "$HOME/.claudebox" ]]; then
       mkdir -p "$HOME/.claudebox"
   fi

   # Fix permissions if needed
   if [[ ! -w "$HOME/.claudebox" ]]; then
       warn "Fixing .claudebox permissions..."
       sudo chown -R "$USER:$USER" "$HOME/.claudebox" || true
   fi

   # Create default allowlist file if it doesn't exist
   local allowlist_file="$PROJECT_CLAUDEBOX_DIR/allowlist"
   
   if [[ ! -f "$allowlist_file" ]]; then
       # Create allowlist with default domains
       cat > "$allowlist_file" <<'EOF'
# Default domains (always allowed):
# api.anthropic.com, console.anthropic.com, statsig.anthropic.com, sentry.io

# GitHub.com
github.com
api.github.com
raw.githubusercontent.com
ssh.github.com
avatars.githubusercontent.com
codeload.github.com
objects.githubusercontent.com
pipelines.actions.githubusercontent.com
ghcr.io
pkg-containers.githubusercontent.com

# GitLab.com
gitlab.com
api.gitlab.com
registry.gitlab.com
uploads.gitlab.com
gitlab.io
*.gitlab.io
*.s3.amazonaws.com
*.amazonaws.com

# Bitbucket.org
bitbucket.org
api.bitbucket.org
altssh.bitbucket.org
bbuseruploads.s3.amazonaws.com
bitbucket-pipelines-prod-us-west-2.s3.amazonaws.com
bitbucket-pipelines-prod-us-east-1.s3.amazonaws.com
bitbucket-pipelines-prod-eu-west-1.s3.amazonaws.com

# Atlassian IP Ranges (Bitbucket Cloud)
104.192.136.0/21
185.166.140.0/22
13.200.41.128/25
18.246.31.128/25

# Optional (Git LFS, Assets)
github-cloud.s3.amazonaws.com
github-releases.githubusercontent.com
github-production-release-asset-2e65be.s3.amazonaws.com
EOF
   fi

   set -- "${DEFAULT_FLAGS[@]}" "$@"

   # Flag Prioritizer System
   # Define control flags and their priority (lower number = higher priority)
   # Using function for Bash 3.2 compatibility
   get_control_flag_priority() {
       case "$1" in
           "--shell-mode") echo 1 ;;
           "--enable-sudo") echo 2 ;;
           "--disable-firewall") echo 3 ;;
           *) echo "" ;;
       esac
   }
   
   # Check if .claude/projects exists, if not remove -c flag
   if [[ ! -d "$PROJECT_CLAUDEBOX_DIR/.claude/projects" ]]; then
       local filtered_args=()
       for arg in "$@"; do
           if [[ "$arg" != "-c" && "$arg" != "--continue" ]]; then
               filtered_args+=("$arg")
           fi
       done
       set -- "${filtered_args[@]}"
   fi
   
   # Extract and sort control flags
   local control_flags=()
   local claude_flags=()
   local temp_args=("$@")
   
   # Extract control flags and separate from Claude flags
   for arg in "${temp_args[@]}"; do
       local priority=$(get_control_flag_priority "$arg")
       if [[ -n "$priority" ]]; then
           control_flags+=("$arg")
       else
           claude_flags+=("$arg")
       fi
   done
   
   # Sort control flags by priority
   if [[ ${#control_flags[@]} -gt 0 ]]; then
       IFS=$'\n' control_flags=($(
           for flag in "${control_flags[@]}"; do
               echo "$(get_control_flag_priority "$flag"):$flag"
           done | sort -n | cut -d: -f2
       ))
   fi
   

   # Handle update command specially to persist changes
   if [[ "${claude_flags[0]:-}" == "update" ]]; then
       local project_folder_name
       project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
       local temp_container="claudebox-update-${project_folder_name}-$$"
       
       # Run update in a named container and capture output
       local update_output
       update_output=$(run_claudebox_container "$temp_container" "attached" ${control_flags[@]+"${control_flags[@]}"} ${claude_flags[@]+"${claude_flags[@]}"} 2>&1)
       echo "$update_output"
       
       # Only commit if an actual update occurred
       if echo "$update_output" | grep -q "Successfully updated\|Verifying update"; then
           fillbar
           docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
           fillbar stop
           success "Claude updated and changes saved to image!"
       fi
       
       # Always remove the container
       docker rm -f "$temp_container" >/dev/null 2>&1
   else
       # For now, just run the container directly without persistence
       # This approach is simpler and more reliable
       run_claudebox_container "" "interactive" ${control_flags[@]+"${control_flags[@]}"} ${claude_flags[@]+"${claude_flags[@]}"}
   fi
}

main "$@"
